# Using pdf-forge from Go

pdf-forge exposes a pure C ABI (`include/rpdf.h`) that Go can consume directly
via **cgo** — no intermediate wrapper library required.

---

## Prerequisites

| Tool                      | Minimum version |
| ------------------------- | --------------- |
| Rust + Cargo              | 1.75            |
| Go                        | 1.21            |
| GCC / Clang (Linux/macOS) | any recent      |
| MinGW-w64 (Windows)       | 13+             |

---

## 1. Build the Rust library

```sh
# from the repo root
cargo build --release
```

This produces:

| Platform | Dynamic                             | Static (import)                    |
| -------- | ----------------------------------- | ---------------------------------- |
| Linux    | `target/release/libpdf_forge.so`    | `target/release/libpdf_forge.a`    |
| macOS    | `target/release/libpdf_forge.dylib` | `target/release/libpdf_forge.a`    |
| Windows  | `target/release/pdf_forge.dll`      | `target/release/pdf_forge.dll.lib` |

---

## 2. The C header

`include/rpdf.h` is auto-generated by **cbindgen** on every `cargo build`.  
It declares two configuration types and eleven functions:

```c
/* ── Configuration types ────────────────────────────────────────────────── */

// Page orientation.
typedef enum RpdfPageOrientation {
    Portrait  = 0,   // default
    Landscape = 1,
} RpdfPageOrientation;

// Optional pipeline configuration.
// Pass a pointer to the *_ex functions, or NULL to use A4 defaults.
typedef struct RpdfPipelineConfig {
    const char *title;          // PDF document title; NULL → "rpdf output"
    float page_width;           // page width in pt;   0 → 595.28 (A4)
    float page_height;          // page height in pt;  0 → 841.89 (A4)
    float page_margin;          // margin in pt;       0 → 40
    RpdfPageOrientation orientation;
} RpdfPipelineConfig;

/* ── Core (default A4 config) ────────────────────────────────────────────── */

// Generate a PDF from an HTML string.
int rpdf_generate_pdf(const uint8_t *html_ptr, uint32_t html_len,
                      uint8_t **out_buf, uint32_t *out_len);

// Same, plus returns the layout config as JSON.
int rpdf_generate_pdf_with_layout(const uint8_t *html_ptr, uint32_t html_len,
                                  uint8_t **out_pdf_buf, uint32_t *out_pdf_len,
                                  char **out_json_ptr);

// Compute the layout only (no rendering). Returns JSON.
int rpdf_compute_layout(const uint8_t *html_ptr, uint32_t html_len,
                        char **out_json_ptr);

// Render a PDF from a previously computed layout JSON.
int rpdf_render_from_layout(const char *json_ptr,
                            uint8_t **out_buf, uint32_t *out_len);

/* ── Config-aware variants (*_ex) ────────────────────────────────────────── */

// Generate a PDF with a custom config (pass NULL cfg for defaults).
int rpdf_generate_pdf_ex(const uint8_t *html_ptr, uint32_t html_len,
                         const RpdfPipelineConfig *cfg,
                         uint8_t **out_buf, uint32_t *out_len);

// Same, plus layout JSON.
int rpdf_generate_pdf_with_layout_ex(const uint8_t *html_ptr, uint32_t html_len,
                                     const RpdfPipelineConfig *cfg,
                                     uint8_t **out_pdf_buf, uint32_t *out_pdf_len,
                                     char **out_json_ptr);

// Compute layout only with a custom config.
int rpdf_compute_layout_ex(const uint8_t *html_ptr, uint32_t html_len,
                           const RpdfPipelineConfig *cfg,
                           char **out_json_ptr);

/* ── Memory management ───────────────────────────────────────────────────── */
void rpdf_free_buffer(uint8_t *buf, uint32_t len);
void rpdf_free_string(char *s);

/* ── Diagnostics ─────────────────────────────────────────────────────────── */
const char *rpdf_last_error(void);  // do NOT free
const char *rpdf_version(void);     // do NOT free
```

### Return codes

| Code | Meaning                 |
| ---- | ----------------------- |
| `0`  | Success                 |
| `1`  | Null pointer argument   |
| `2`  | Invalid UTF-8 in input  |
| `3`  | Pipeline / layout error |
| `4`  | Render / PDF error      |

---

## 3. Calling from Go via cgo

### Minimal example

```go
package main

/*
#cgo CFLAGS: -I/path/to/rpdf/include
#cgo linux  LDFLAGS: -L/path/to/rpdf/target/release -lpdf_forge -lpthread -ldl -lm
#cgo darwin LDFLAGS: -L/path/to/rpdf/target/release -lpdf_forge -lpthread -ldl -lm
#cgo windows LDFLAGS: -L/path/to/rpdf/target/release -lpdf_forge -lws2_32 -lbcrypt -lntdll -luserenv
#include "rpdf.h"
#include <stdlib.h>
*/
import "C"
import (
    "fmt"
    "os"
    "unsafe"
)

func generatePDF(html []byte) ([]byte, error) {
    htmlPtr := (*C.uint8_t)(unsafe.Pointer(&html[0]))
    htmlLen := C.uint32_t(len(html))

    var outBuf *C.uint8_t
    var outLen C.uint32_t

    rc := C.rpdf_generate_pdf(htmlPtr, htmlLen, &outBuf, &outLen)
    if rc != 0 {
        return nil, fmt.Errorf("rpdf error %d: %s", rc, C.GoString(C.rpdf_last_error()))
    }
    defer C.rpdf_free_buffer(outBuf, outLen)

    // Copy into a Go-owned slice before freeing the Rust buffer.
    return C.GoBytes(unsafe.Pointer(outBuf), C.int(outLen)), nil
}

func main() {
    html, _ := os.ReadFile("report.html")
    pdf, err := generatePDF(html)
    if err != nil {
        fmt.Fprintln(os.Stderr, err)
        os.Exit(1)
    }
    os.WriteFile("report.pdf", pdf, 0o644)
    fmt.Printf("Generated %d bytes\n", len(pdf))
}
```

> **Important:** always call `C.rpdf_free_buffer` (or `C.rpdf_free_string`) to
> release memory allocated by Rust. Using Go's `defer` immediately after
> checking the return code is the idiomatic pattern.

---

## 4. Using a custom pipeline config

All three `*_ex` functions accept a `*C.RpdfPipelineConfig`.  
Pass `nil` to fall back to A4 defaults, which is identical to calling the
non-`_ex` variant.

```go
// generatePDFEx converts HTML to PDF with a fully customisable config.
// Any zero value falls back to the built-in A4 default.
func generatePDFEx(html []byte, title string, landscape bool, marginPt float32) ([]byte, error) {
	if len(html) == 0 {
		return nil, errors.New("html must not be empty")
	}

	// Build the C config struct on the stack.
	var cfg C.RpdfPipelineConfig

	// Title: allocate a C string if provided, free it after the call.
	if title != "" {
		cTitle := C.CString(title)
		defer C.free(unsafe.Pointer(cTitle))
		cfg.title = cTitle
	} // else cfg.title remains nil → library uses default

	if landscape {
		cfg.orientation = C.Landscape
	} else {
		cfg.orientation = C.Portrait
	}

	// page_width and page_height stay 0.0 → defaults (A4)
	cfg.page_margin = C.float(marginPt) // 0.0 also falls back to default (40 pt)

	htmlPtr := (*C.uint8_t)(unsafe.Pointer(&html[0]))
	htmlLen := C.uint32_t(len(html))

	var outBuf *C.uint8_t
	var outLen C.uint32_t

	rc := C.rpdf_generate_pdf_ex(htmlPtr, htmlLen, &cfg, &outBuf, &outLen)
	if rc != 0 {
		errPtr := C.rpdf_last_error()
		if errPtr != nil {
			return nil, fmt.Errorf("rpdf error (code %d): %s", int(rc), C.GoString(errPtr))
		}
		return nil, fmt.Errorf("rpdf_generate_pdf_ex failed with code %d", int(rc))
	}
	defer C.rpdf_free_buffer(outBuf, outLen)

	return C.GoBytes(unsafe.Pointer(outBuf), C.int(outLen)), nil
}
```

To skip configuration entirely, pass `nil`:

```go
rc := C.rpdf_generate_pdf_ex(htmlPtr, htmlLen, nil, &outBuf, &outLen)
```

---

## 5. Build & run the bundled example

The full working example lives in `examples/go/main.go`.

### Linux / macOS

```sh
# 1. Build the Rust library (once)
cargo build --release

# 2. Build the Go binary
cd examples/go
CGO_LDFLAGS="-L../../target/release -lpdf_forge -lpthread -ldl -lm" \
  go build -o generate_pdf .

# 3. Run it
LD_LIBRARY_PATH=../../target/release \
  ./generate_pdf ../../templates/minimal.html out.pdf

# Optional: embed a document title
LD_LIBRARY_PATH=../../target/release \
  ./generate_pdf --title "Q4 Report" ../../templates/invoice.html invoice.pdf
```

### Windows (MinGW-w64 + GCC)

```bat
REM 1. Build the Rust library
cargo build --release

REM 2. Build the Go binary
cd examples\go
set CGO_LDFLAGS=-L../../target/release -lpdf_forge -lws2_32 -lbcrypt -lntdll -luserenv
go build -o generate_pdf.exe .

REM 3. Copy the DLL next to the binary (or add target\release to PATH)
copy ..\..\target\release\pdf_forge.dll .

REM 4. Run
generate_pdf.exe --title "Q4 Report" ..\..\templates\invoice.html invoice.pdf
```

---

## 6. Static vs dynamic linking

### Dynamic (default above)

The binary loads `libpdf_forge.so` / `pdf_forge.dll` at runtime.  
Set `LD_LIBRARY_PATH` (Linux), `DYLD_LIBRARY_PATH` (macOS), or copy the DLL
beside the executable (Windows).

### Static (Linux / macOS)

Link against `libpdf_forge.a` instead:

```sh
CGO_LDFLAGS="../../target/release/libpdf_forge.a -lpthread -ldl -lm" \
  go build -o generate_pdf .
```

The resulting binary has no runtime dependency on the Rust library.

---

## 7. Advanced: layout round-trip

Compute the layout once, cache the JSON, then render later without re-parsing
the HTML — useful for preview + export workflows:

```go
// ── Step 1: compute layout ─────────────────────────────────────────────────
htmlPtr := (*C.uint8_t)(unsafe.Pointer(&html[0]))
htmlLen := C.uint32_t(len(html))

var jsonPtr *C.char
rc := C.rpdf_compute_layout(htmlPtr, htmlLen, &jsonPtr)
if rc != 0 {
    return fmt.Errorf("layout error: %s", C.GoString(C.rpdf_last_error()))
}
defer C.rpdf_free_string(jsonPtr)
layoutJSON := C.GoString(jsonPtr) // copy to Go string

// ── Step 2: render PDF from cached JSON ────────────────────────────────────
cJSON := C.CString(layoutJSON)
defer C.free(unsafe.Pointer(cJSON))

var outBuf *C.uint8_t
var outLen C.uint32_t
rc = C.rpdf_render_from_layout(cJSON, &outBuf, &outLen)
if rc != 0 {
    return fmt.Errorf("render error: %s", C.GoString(C.rpdf_last_error()))
}
defer C.rpdf_free_buffer(outBuf, outLen)

pdf := C.GoBytes(unsafe.Pointer(outBuf), C.int(outLen))
```

---

## 8. Memory ownership rules

| Pointer                                                                      | Who allocates       | How to free                    |
| ---------------------------------------------------------------------------- | ------------------- | ------------------------------ |
| `*out_buf` from `rpdf_generate_pdf` / `rpdf_generate_pdf_ex` / `rpdf_render_from_layout`                                                     | Rust                | `C.rpdf_free_buffer(buf, len)` |
| `*out_json_ptr` from `rpdf_compute_layout` / `rpdf_compute_layout_ex` / `rpdf_generate_pdf_with_layout` / `rpdf_generate_pdf_with_layout_ex`  | Rust                | `C.rpdf_free_string(ptr)`      |
| `cfg.title` C string you allocate with `C.CString` for `*_ex` calls                                                                         | Go/C                | `C.free(unsafe.Pointer(ptr))`  |
| `rpdf_last_error()` return value                                             | Rust (thread-local) | **do not free**                |
| `rpdf_version()` return value                                                | Rust (static)       | **do not free**                |
| `C.CString(...)` you allocate                                                | Go/C                | `C.free(unsafe.Pointer(ptr))`  |
