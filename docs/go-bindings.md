# Using pdf-forge from Go

pdf-forge exposes a pure C ABI (`include/rpdf.h`) that Go can consume directly
via **cgo** — no intermediate wrapper library required.

---

## Prerequisites

| Tool                      | Minimum version |
| ------------------------- | --------------- |
| Rust + Cargo              | 1.75            |
| Go                        | 1.21            |
| GCC / Clang (Linux/macOS) | any recent      |
| MinGW-w64 (Windows)       | 13+             |

---

## 1. Build the Rust library

```sh
# from the repo root
cargo build --release
```

This produces:

| Platform | Dynamic                             | Static (import)                    |
| -------- | ----------------------------------- | ---------------------------------- |
| Linux    | `target/release/libpdf_forge.so`    | `target/release/libpdf_forge.a`    |
| macOS    | `target/release/libpdf_forge.dylib` | `target/release/libpdf_forge.a`    |
| Windows  | `target/release/pdf_forge.dll`      | `target/release/pdf_forge.dll.lib` |

---

## 2. The C header

`include/rpdf.h` is auto-generated by **cbindgen** on every `cargo build`.  
It declares eight functions:

```c
// Generate a PDF from an HTML string.
int rpdf_generate_pdf(const uint8_t *html_ptr, uint32_t html_len,
                      uint8_t **out_buf, uint32_t *out_len);

// Same, plus returns the layout config as JSON.
int rpdf_generate_pdf_with_layout(const uint8_t *html_ptr, uint32_t html_len,
                                  uint8_t **out_pdf_buf, uint32_t *out_pdf_len,
                                  char **out_json_ptr);

// Compute the layout only (no rendering). Returns JSON.
int rpdf_compute_layout(const uint8_t *html_ptr, uint32_t html_len,
                        char **out_json_ptr);

// Render a PDF from a previously computed layout JSON.
int rpdf_render_from_layout(const char *json_ptr,
                            uint8_t **out_buf, uint32_t *out_len);

// Memory management
void rpdf_free_buffer(uint8_t *buf, uint32_t len);
void rpdf_free_string(char *s);

// Diagnostics
const char *rpdf_last_error(void);  // do NOT free
const char *rpdf_version(void);     // do NOT free
```

### Return codes

| Code | Meaning                 |
| ---- | ----------------------- |
| `0`  | Success                 |
| `1`  | Null pointer argument   |
| `2`  | Invalid UTF-8 in input  |
| `3`  | Pipeline / layout error |
| `4`  | Render / PDF error      |

---

## 3. Calling from Go via cgo

### Minimal example

```go
package main

/*
#cgo CFLAGS: -I/path/to/rpdf/include
#cgo linux  LDFLAGS: -L/path/to/rpdf/target/release -lpdf_forge -lpthread -ldl -lm
#cgo darwin LDFLAGS: -L/path/to/rpdf/target/release -lpdf_forge -lpthread -ldl -lm
#cgo windows LDFLAGS: -L/path/to/rpdf/target/release -lpdf_forge -lws2_32 -lbcrypt -lntdll -luserenv
#include "rpdf.h"
#include <stdlib.h>
*/
import "C"
import (
    "fmt"
    "os"
    "unsafe"
)

func generatePDF(html []byte) ([]byte, error) {
    htmlPtr := (*C.uint8_t)(unsafe.Pointer(&html[0]))
    htmlLen := C.uint32_t(len(html))

    var outBuf *C.uint8_t
    var outLen C.uint32_t

    rc := C.rpdf_generate_pdf(htmlPtr, htmlLen, &outBuf, &outLen)
    if rc != 0 {
        return nil, fmt.Errorf("rpdf error %d: %s", rc, C.GoString(C.rpdf_last_error()))
    }
    defer C.rpdf_free_buffer(outBuf, outLen)

    // Copy into a Go-owned slice before freeing the Rust buffer.
    return C.GoBytes(unsafe.Pointer(outBuf), C.int(outLen)), nil
}

func main() {
    html, _ := os.ReadFile("report.html")
    pdf, err := generatePDF(html)
    if err != nil {
        fmt.Fprintln(os.Stderr, err)
        os.Exit(1)
    }
    os.WriteFile("report.pdf", pdf, 0o644)
    fmt.Printf("Generated %d bytes\n", len(pdf))
}
```

> **Important:** always call `C.rpdf_free_buffer` (or `C.rpdf_free_string`) to
> release memory allocated by Rust. Using Go's `defer` immediately after
> checking the return code is the idiomatic pattern.

---

## 4. Build & run the bundled example

The full working example lives in `examples/go/main.go`.

### Linux / macOS

```sh
# 1. Build the Rust library (once)
cargo build --release

# 2. Build the Go binary
cd examples/go
CGO_LDFLAGS="-L../../target/release -lpdf_forge -lpthread -ldl -lm" \
  go build -o generate_pdf .

# 3. Run it
LD_LIBRARY_PATH=../../target/release \
  ./generate_pdf ../../templates/minimal.html out.pdf

# Optional: embed a document title
LD_LIBRARY_PATH=../../target/release \
  ./generate_pdf --title "Q4 Report" ../../templates/invoice.html invoice.pdf
```

### Windows (MinGW-w64 + GCC)

```bat
REM 1. Build the Rust library
cargo build --release

REM 2. Build the Go binary
cd examples\go
set CGO_LDFLAGS=-L../../target/release -lpdf_forge -lws2_32 -lbcrypt -lntdll -luserenv
go build -o generate_pdf.exe .

REM 3. Copy the DLL next to the binary (or add target\release to PATH)
copy ..\..\target\release\pdf_forge.dll .

REM 4. Run
generate_pdf.exe --title "Q4 Report" ..\..\templates\invoice.html invoice.pdf
```

---

## 5. Static vs dynamic linking

### Dynamic (default above)

The binary loads `libpdf_forge.so` / `pdf_forge.dll` at runtime.  
Set `LD_LIBRARY_PATH` (Linux), `DYLD_LIBRARY_PATH` (macOS), or copy the DLL
beside the executable (Windows).

### Static (Linux / macOS)

Link against `libpdf_forge.a` instead:

```sh
CGO_LDFLAGS="../../target/release/libpdf_forge.a -lpthread -ldl -lm" \
  go build -o generate_pdf .
```

The resulting binary has no runtime dependency on the Rust library.

---

## 6. Advanced: layout round-trip

Compute the layout once, cache the JSON, then render later without re-parsing
the HTML — useful for preview + export workflows:

```go
// ── Step 1: compute layout ─────────────────────────────────────────────────
htmlPtr := (*C.uint8_t)(unsafe.Pointer(&html[0]))
htmlLen := C.uint32_t(len(html))

var jsonPtr *C.char
rc := C.rpdf_compute_layout(htmlPtr, htmlLen, &jsonPtr)
if rc != 0 {
    return fmt.Errorf("layout error: %s", C.GoString(C.rpdf_last_error()))
}
defer C.rpdf_free_string(jsonPtr)
layoutJSON := C.GoString(jsonPtr) // copy to Go string

// ── Step 2: render PDF from cached JSON ────────────────────────────────────
cJSON := C.CString(layoutJSON)
defer C.free(unsafe.Pointer(cJSON))

var outBuf *C.uint8_t
var outLen C.uint32_t
rc = C.rpdf_render_from_layout(cJSON, &outBuf, &outLen)
if rc != 0 {
    return fmt.Errorf("render error: %s", C.GoString(C.rpdf_last_error()))
}
defer C.rpdf_free_buffer(outBuf, outLen)

pdf := C.GoBytes(unsafe.Pointer(outBuf), C.int(outLen))
```

---

## 7. Memory ownership rules

| Pointer                                                                      | Who allocates       | How to free                    |
| ---------------------------------------------------------------------------- | ------------------- | ------------------------------ |
| `*out_buf` from `rpdf_generate_pdf` / `rpdf_render_from_layout`              | Rust                | `C.rpdf_free_buffer(buf, len)` |
| `*out_json_ptr` from `rpdf_compute_layout` / `rpdf_generate_pdf_with_layout` | Rust                | `C.rpdf_free_string(ptr)`      |
| `rpdf_last_error()` return value                                             | Rust (thread-local) | **do not free**                |
| `rpdf_version()` return value                                                | Rust (static)       | **do not free**                |
| `C.CString(...)` you allocate                                                | Go/C                | `C.free(unsafe.Pointer(ptr))`  |
